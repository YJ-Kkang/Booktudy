# [Booktudy] 객체지향의 사실과 오해_4챕터(250102)

---


# 4. 역할, 책임, 협력

각 개인이 처해 있는 정황 또는 문맥(context)이 인간의 행동 방식을 결정함.

→ `인간의 행동을 결정`하는 문맥: `타인과의 협력`

→ `협력이 얼마나 적절`한지에 따라 `행동의 적합성`이 결정되며, 문맥이 `인간의 행동 방식`을 결정함.



- 객체의 세계에서도 `협력`이라는 문맥이 **객체의 행동 방식**을 결정함.

  \- 중요한 것: `개별 객체` < `객체들 사이에 이뤄지는 협력`

>어떤 `협력`에 참여하는가 → 객체에 필요한 `행동` 결정
> 
> 필요한 `행동` → 객체의 `상태` 결정

<br>

## 협력
### 요청하고 응답하며 협력하는 사람들
- 협력의 본질: 요청과 응답으로 연결되는 사람들의 네트워크

- **`협력`**: 한 사람이 다른 사람에게 도움을 **요청**할 때 시작됨.

  → `요청을 받은 사람`은 일을 처리한 후, `요청한 사람`에게 필요한 지식이나 서비스를 제공하는 것으로 요청에 **응답**함.

  → `협력`은 **다수의 요청과 응답**으로 구성되며, 전체적으로 **다수의 연쇄적인 요청과 응답의 흐름**으로 구성됨.


- **객체지향의 세계**는 `동일한 목적`을 달성하기 위해 `협력`하는 `객체들의 공동체`

>- 앨리스의 이야기에서 <하트 잭의 재판>이라는 동일한 목적을 달성하기 위해 많은 사람이 협력한다.
>
>1) 누군가 왕(판사 역할)에게 재판을 `요청`함으로써 재판이 시작
>2) 왕이 하얀 토끼에게 증인을 부를 것을 `요청`
>3) 왕의 요청을 받은 토끼는 모자 장수에게 증인석으로 입장할 것을 `요청`
>4) 모자 장수는 증인석에 입장함으로써 토끼의 요청에 `응답`
>5) 모자 장수의 입장은 왕이 토끼에게 요청했던 증인 호출에 대한 `응답`이기도 함
>6) 이제 왕은 모자 장수에게 증언할 것을 `요청`
>7) 모자 장수는 자신이 알고 있는 내용을 증언함으로써 왕의 요청에 `응답`

→ 어떤 등장인물들이 특정한 요청을 받아들일 수 있는 이유: 그 요청에 대해 적절한 방식으로 응답하는 데 필요한 지식과 행동 방식을 가지고 있기 때문

→ `요청` & `응답`: '협력에 참여하는 객체'가 '수행할 책임'을 **정의**함

<br>

## 책임
- **`책임`**: 어떤 객체가 어떤 요청에 대해 대답해 줄 수 있거나, 적절한 행동을 할 의무가 있는 경우

  → **어떤 대상에 대한 요청**은 `그 대상`이 **요청을 처리할 책임**이 있음을 암시함.

### 책임의 분류
`협력에 참여하는 객체들`은 '목표를 달성하는 데 필요한 책임'을 **수행**함.

- **책임**: 객체에 의해 정의되는 응집도 있는 행위의 집합

  → `객체가 알아야 하는 정보`와 `객체가 수행할 수 있는 행위`에 대해 **개략적으로 서술한 문장**

  → **객체의 책임**은 `객체가 무엇을 알고 있는가(knowing)`와 `무엇을 할 수 있는가(doing)`로 구성됨.


>- **하는 것(doing)**
>>\- 객체를 생성하거나 계산을 하는 등 **스스로 하는** 것
>>
>>\- `다른 객체의 행동`을 **시작**시키는 것
>>
>>\- `다른 객체의 활동`을 **제어** 및 **조절**하는 것

>- **아는 것(knowing)**
>>\- `개인적인 정보`에 관해 아는 것
>>
>>\- `관련된 객체`에 관해 아는 것
>>
>>\- `자신이 '유도'하거나 '계산'할 수 있는 것`에 관해 아는 것

→ `책임`: 객체지향 설계의 품질을 결정하는 가장 중요한 요소

→ `적절한 객체`에게 `적절한 책임`을 할당해야 함.

책임이 불분명한 객체들은 애플리케이션의 미래 역시 불분명하게 만든다.

- **책임**: `객체의 외부에 제공해 줄 수 있는 정보(아는 것의 측면)` + `외부에 제공해 줄 수 있는 서비스(하는 것의 측면)`의 목록

  → `책임`은 객체의 **공용 인터페이스(public interface)**를 구성(추후 다룰 캡슐화와 관련 있음)

### 책임과 메시지
**협력** 안에서 **객체**는 `다른 객체로부터 요청이 전송됐을 경우`에만 `자신에게 주어진 책임을 수행`함.

즉, 한 객체가 다른 객체에게 **전송한 `요청`**은 그 요청을 **`수신한 객체`의 `책임`이 수행**되게 한다.

- **`메시지 전송(message-send)`**: '객체'가 '다른 객체'에게 **주어진 책임**을 **수행**하도록 **요청 보내는 것**.

  → `송신자`: '메시지를 전송'함으로써 **협력을 요청**하는 객체

  → `수신자`: '메시지를 받아' **요청을 처리**하는 객체

  → `메시지`: '협력'을 위해 한 객체가 **다른 객체로 접근할 수 있는 유일한 방법**

>**책임**: 협력이라는 문맥 속에서 요청을 수신하는 한 쪽의 객체 관점에서 무엇을 할 수 있는지를 나열하는 것
> 
> **메시지**: 협력에 참여하는 두 객체 사이의 관계를 강조한 것

**주의할 점**: `책임의 수준` != `메시지의 수준`

\- `책임`은 '객체가 협력에 참여하기 위해 수행해야 하는 행위'를 **상위 수준**에서 개략적으로 서술한 것.

\- 책임을 결정한 후 실제로 협력을 정제하면서 이를 메시지로 변환할 때는 `하나의 책임`이 `여러 메시지`로 **분할**되는 것이 일반적.

<br>

## 역할
### 책임의 집합이 의미하는 것
- **`'어떤 객체'가 '수행하는 책임의 집합'`**: `'객체'가 '협력 안에서 수행하는 역할'`을 암시.

><이상한 나라의 앨리스>의 재판 장면에서 아래의 세 유형은 모두 동일한 과정으로 이루어져 있다.
>1) `왕`이 판사, `모자 장수`가 증인
>2) `왕`이 판사, `요리사`가 증인
>3) `여왕`이 판사, `앨리스`가 증인
>

   → 서로 다른 세 개의 재판 과정, 즉 세 개의 협력.

   → `재판`이라는 협력 과정 속에서 왕과 여왕의 역할(role)을 `판사`로, 모자 장수와 요리사, 앨리스의 역할(role)을 `증인`으로 하면 세 가지 협력을 모두 포괄할 수 있는 하나의 협력으로 **`추상화`**할 수 있다.

- **역할(role)**: 협력 내에서 '`다른 객체`로 대체할 수 있음'을 나타내는 일종의 표식
  → `역할`을 이용해 `협력을 추상화`하면 `어떤 객체라도 협력에 참여`할 수 있음
  (이때, '역할을 대체할 수 있는 객체'는 **동일한 메시지(책임)를 이해할 수 있는 객체**로 한정됨)

- **동일한 역할을 수행하는 객체들**은 `동일한 메시지를 수신할 수 있음` == `동일한 책임을 수행할 수 있음`

<br>

- **역할**의 개념 사용
1) `단순성(simplicity)`: '유사한 협력'을 **추상화**해서 `인지 과부하 ↓`
2) `유연성(flexibility)`: '다양한 객체들이 협력에 참여'할 수 있기에 **협력**이 좀 더 **`유연`**해짐
3) `재사용성(reusability)`: 다양한 객체들이 '동일한 협력에 참여'할 수 있기에 `재사용성 ↑`
>역할은 객체지향 설계의 단순성, 유연성, 재사용성을 뒷받침하는 핵심 개념이다.

<br>

### 협력의 추상화
- 역할의 가장 큰 가치: 하나의 협력 안에 여러 종류의 객체가 참여할 수 있게 함으로써 협력을 **추상화**할 수 있음.

  → `협력의 추상화`는 설계자가 다뤄야 하는 협력의 개수를 줄이는 동시에 구체적인 객체를 추상적인 역할로 대체함으로써 협력의 양상을 단순화함.

  → 결과적으로 애플리케이션의 설계를 이해하고 기억하기 쉬워짐.

즉, 역할을 이용하면 `협력을 추상화`함으로써 `단순화`할 수 있다.

(구체적인 객체로 추상적인 역할을 대체해서 동일한 구조의 협력을 다양한 문맥에서 재사용할 수 있는 능력

→ 근본적으로 `역할의 대체 가능성`에서 비롯됨)

<br>

### 대체 가능성
- `역할`: 협력 안에서 구체적인 객체로 대체될 수 있는 추상적인 협력자

  → `역할의 의미` == `다른 객체에 의해 대체 가능함`

  (이때, 객체가 역할을 대체하기 위해서는 `행동이 호환되어야 함` == `협력 안에서 역할이 수행하는 모든 책임을 동일하게 수행할 수 있어야 함`)


- `객체가 가지는 책임` >= `역할이 암시하는 책임`

  → 대부분의 경우에 '객체의 타입'과 '역할' 사이에는 **일반화/특수화 관계**가 성립하는 것이 일반적

  (`역할 - 일반화` / `객체의 타입 - 특수화`)

  → 역할이 협력을 추상적으로 만들 수 있는 이유: **역할 자체가 객체의 추상화**이기 때문.


- `역할의 대체 가능성` == `행위 호환성` == `동일한 책임의 수행`

<br>

## 객체의 모양을 결정하는 협력
데이터는 단지 객체가 행위를 수행하는 데 필요한 재료일 뿐이다.
- 객체 존재 이유: `행위를 수행`하며 `협력에 참여`하기 위해

  → 실제로 중요한 것: **`객체의 행동(책임)`**


- `정적인 클래스`보다 협력에 참여하는 `동적인 객체`가 중요

  → 클래스는 단지 시스템에 필요한 객체를 표현하고 생성하기 위해 프로그래밍 언어가 제공하는 구현 메커니즘이다.


- **객체지향의 핵심**

  `클래스`를 어떻게 구현할 것인가 (X)

  `객체`가 협력 안에서 **어떤 책임과 역할을 수행**할지 **결정**하는 것 (O)

<br>

### 협력을 따라 흐르는 객체의 책임
`올바른 객체 설계`를 위해선 먼저 `견고하고 깔끔한 협력 설계`가 선행되어야 함.
- `협력을 설계한다` == `설계에 참여하는 객체들이 주고받을 요청과 응답의 흐름을 결정한다`

  → 이렇게 결정된 `요청과 응답의 흐름`은 객체가 협력에 참여하기 위해 수행될 책임이 됨.

>일단 `객체에게 책임을 할당`하고 나면 '**책임**은 `객체가 외부에 제공하게 될 '행동'`'이 된다.
> 
> 협력이라는 문맥에서 객체가 수행하게 될 적절한 책임, 즉 행동을 결정한 후에 '그 행동을 수행하는 데 필요한 **데이터**'를 고민해야 한다.
그리고 객체가 협력에 참여하기 위해 필요한 데이터와 행동이 어느 정도 결정된 후에 **클래스의 구현 방법**을 결정해야 한다.
결과적으로 `클래스와 데이터`는 **'협력과 책임의 집합'이 결정된 후**에야 무대 위에 등장할 수 있다.
>>1) 협력을 구성하는 데 필요한 일련의 `책임` 고안
>>
>>2) 책임을 수행하는 데 필요한 `객체 선택`(책임을 각 객체에 할당)
>>
>>3) 할당된 책임은 **객체들이 외부에 제공**하게 될 `행동을 정의`하게 됨
>>
>>4) 행동이 결정됐으니, 각 객체가 필요로 하는 `데이터 정의`
>>
>>5) 데이터와 행동이 결정된 후, 객체를 구현하는 `클래스 개발`

- 객체지향 시스템에서 가장 중요한 것: `충분히 자율적`인 동시에 `충분히 협력적`인 `객체`를 창조하는 것

  → 먼저 객체를 `충분히 협력적`으로 만든 후, 협력이라는 문맥 안에서 객체를 `충분히 자율적`으로 만들어야 함.

<br>

## 객체지향 설계 기법
- **`책임-주도 설계(Responsibility-Driven Design)`**

  '협력에 필요한 책임들'을 `식별`하고 '적합한 객체'에게 `책임을 할당`하는 방식으로 애플리케이션을 설계



- **`디자인 패턴(Design Pattern)`**

  전문가들이 '반복적으로 사용하는 해결 방법'을 정의해 놓은 `설계 템플릿`의 모음.

  `패턴`은 전문가들이 특정 문제를 해결하기 위해 이미 식별해 놓은 역할, 책임, 협력의 모음임.




- **`테스트-주도 개발(Test-Driven Development, TDD)`**

  테스트를 먼저 작성하고, 테스트를 통과하는 구체적인 코드를 추가하며 애플리케이션을 완성해가는 방식.

  테스트가 아니라 설계를 위한 기법임.

  → **핵심**
  테스트 작성(X): 테스트는 단지 테스트-주도 개발을 통해 얻을 수 있는 별도의 보너스 같은 것.

  **실제 목적**: 구체적인 코드를 작성해 나가면서 `역할, 책임, 협력을 식별`하고

  식별된 역할, 책임, 협력이 `적합한지 피드백`받는 것.

<br>

### 책임-주도 설계
- 객체지향 시스템: 역할과 책임을 수행하는 자율적인 객체들의 공동체

  → 결국 `객체지향 설계`란 '애플리케이션의 기능을 구현하기 위한 협력 관계를 고안'하고, '협력에 필요한 역할과 책임을 식별'한 후, 이를 수행할 수 있는 '적절한 객체를 식별해 나가는 과정'이다.

- 핵심: `올바른 책임`을 `올바른 객체`에게 **할당**할 것.

- 현재 가장 널리 받아들여지는 객체지향 설계 방법: `책임-주도 설계`

  (`객체의 책임`을 중심으로 시스템을 구축하는 설계 방법)


>1) 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
>
>2) 시스템 책임을 더 작은 책임으로 분할한다.
>
>3) 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
>
>4) 객체가 책임을 수행하는 중에 다른 객체의 도움이 필요한 경우, 이를 책임질 적절한 객체 또는 역할을 찾는다.
>
>5) 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.

→ 역할, 책임, 협력은 유연하고 견고한 객체지향 시스템을 만드는 데 필요한 가장 중요한 재료.

### 디자인 패턴
`책임-주도 설계`는 '객체의 역할, 책임, 협력'을 고안하기 위한 **방법과 절차**를 제시한다.

반면, `디자인 패턴`은 `책임-주도 설계`의 **결과**를 표현한다.

- **패턴**: 모범이 되는 설계

  즉, 특정한 상황에서 설계를 돕기 위해 모방하고 수정할 수 있는 과거의 설계 경험.



일반적으로 `디자인 패턴`은 '반복적으로 발생하는 문제'와 '그 문제에 대한 해법'의 쌍으로 정의됨.

→ `디자인 패턴` == `유사한 상황에서 반복적으로 적용할 수 있는 '책임-주도 설계'의 결과물` == `지름길`


- 디자인 패턴은 공통적으로 사용할 수 있는 역할, 책임, 협력의 템플릿이다.

<br>

### 테스트-주도 개발
- `테스트-주도 개발`: **애자일 방법론**의 한 종류인 **XP**의 **기본 프랙티스**로 소개되며 주목받기 시작함.


>**📌 참고하면 좋을 내용** / `출처: 2024 시나공 정보처리기사 필기 기본서 (길벗 R&D 저)`
>- 애자일 방법론
>>\-  `고객의 요구사항 변화에 유연하게 대응`할 수 있도록 일정한 주기를 반복하며 개발과정을 진행
>>
>>\- 어느 특정 개발 방법론이 아니라 좋은 것을 빠르고 낭비 없게 만들기 위해 `고객과의 소통에 초점을 맞춘 방법론을 통칭`함
>>
>>\- `스프린트(Sprint)` 또는 `이터레이션(Iteration)`이라고 불리는 **짧은 개발 주기**를 반복, 반복되는 주기마다 만들어지는 결과물에 대한 고객의 평가와 요구를 적극 수용함
>>
>>\- 각 개발주기에서는 고객의 요구사항에 우선순위를 부여하여 개발 작업을 진행함
>>
>>\- 소규모 프로젝트, 고도로 숙달된 개발자, 급변하는 요구사항에 적합
>>
>>- 애자일 모형을 기반으로 하는 소프트웨어 개발 모형
>>>1) 스크럼(Scrum)
>>>
>>>2) **[XP](https://ko.wikipedia.org/wiki/%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%A6%BC_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)**(eXtreme Programming):
>>>>익스트림 프로그래밍의 특징은 `테스팅`
>>>>
>>>>(프로그래머들이 코딩할 때 테스트코드를 작성하도록 함과 동시에 테스트를 기반으로 프로젝트를 완성시켜 나가도록 함)
>>>
>>>3) 칸반(Kanban)
>>>
>>>4) Lean
>>>
>>>5) 크리스탈(Crystal)
>>>
>>>6) ASD(Adaptive Software Development)
>>>
>>>7) 기능 중심 개발(FDD: Feature Driven Development)
>>>
>>>8) DSDM(Dynamic System Development Method)
>>>
>>>9) DAD(Disciplined Agile Delivery) ...
>
| 구분                 | 폭포수 모형                   | 애자일                    |
|----------------------|-------------------------------|---------------------------|
| 새로운 요구사항 반영 | 어려움                        | 지속적으로 반영           |
| 고객과의 의사소통    | 적음                          | 지속적임                  |
| 테스트               | 마지막에 모든 기능을 테스트   | 반복되는 일정 주기가 끝날 때마다 테스트 |
| 개발 중심            | 계획, 문서(메뉴얼)            | 고객                      |

<br>

- 기본 흐름
1) 실패하는 테스트 작성
2) 테스트를 통과하는 가장 간단한 코드를 작성(이 시간 동안에는 중복이 있어도 무방)
3) 리펙터링을 통해 중복을 제거





- `테스트-주도 개발`을 통해 `작동하는 깔끔한 코드`를 얻을 수 있음.

  → 응집도 높고, 결합도 낮은 클래스로 구성된 시스템을 개발할 수 있게 해주는 최상의 프랙티스이다.

  → 객체가 이미 존재한다고 가정하고 객체에게 어떤 메시지를 전송할 것인지에 관해 먼저 생각

  (이때 역할, 책임, 협력의 관점에서 객체를 바라보아야 함)






- `테스트-주도 개발`: 테스트를 작성하는 것 (X)

  `책임을 수행할 객체` 또는 `클라이언트가 기대하는 객체`의 **역할**이 '메시지를 수신'할 때 **어떤 결과를 반환**하고 **그 과정에서 어떤 객체와 협력**할 것인지에 대한 기대를 `코드의 형태로 작성`하는 것 (O)





- `테스트-주도 개발`은 `책임-주도 설계`의 기본 개념을 따른다.

  즉, `책임-주도 설계`를 통해 도달해야 하는 목적지를 테스트라는 안전장치를 통해 좀 더 빠르고 견고한 방법으로 도달할 수 있도록 해주는 최상의 설계 프랙티스.

  → `책임-주도 설계`의 기본 개념과 다양한 원칙과 프랙티스, 패턴을 종합적으로 이해하고 좋은 설계에 대한 감각과 경험을 길러야만 적용할 수 있는 설계 기법임

  (`역할, 책임, 협력에 집중` + `'객체지향의 원칙을 적용'하려는 깊이 있는 고민과 노력` 필요)


---

💬 [스터디 진행 기록(객체지향의 사실과 오해_4챕터_250102)](https://flat-argument-d72.notion.site/250102-_4-16e7faba9f3f80039d79d0e021696363?pvs=4)

🎬 [스터디 진행 영상(객체지향의 사실과 오해_4챕터_250102)](https://www.youtube.com/watch?v=t9o8vDQrTus)
